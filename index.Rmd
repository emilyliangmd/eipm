---
title: "Reproducible Supplement"
description: For manuscript "Development and validation of predictive models of early immune effector cell-associated hematotoxicity (eIPMs)" by Liang et al., 2024
author:
  - name: Emily C. Liang, MD
    affiliation: University of Washington and Fred Hutchinson Cancer Center
date: "`r Sys.Date()`"
output:
  distill::distill_article:
    code_folding: true
    toc: true
    toc_float: true
    toc_depth: 3
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(message = FALSE, warning = FALSE) 
library(distill)
library(knitr)
library(rmarkdown)
```

## Load the required packages
```{r}
library(openxlsx)
library(here)
library(janitor)
library(tidyverse)
library(labelled)
library(zoo)
library(latrend)
library(ggplot2)
library(ggnewscale)
library(scales)
library(ggrepel)
library(gtsummary)
library(prodlim)
library(ggsurvfit)
library(Epi)
library(pmsampsize)
library(caret)
library(rms)
library(tidymodels)
library(glmnet)
library(probably)
library(vip)
library(runway)
library(cutpointr)
library(dcurves)
library(survival)
library(patchwork)
theme_set(theme_bw())
theme_gtsummary_compact()
```

## Automated eICAHT grading

### Import data
```{r}
# Clinical data
# Already excludes the patients who ho died prior to day +14 after CAR T-cell infusion, 
# who had more than 7 consecutive days of missing ANC values, or 
# who had a second CAR T-cell infusion within 30 days of the first CAR T-cell infusion 
df <-
  read.xlsx(
    here(
      "dfs",
      "Outputs",
      "File for eIPM Supplement.xlsx"
    ),
    detectDates = TRUE
  )

# CBC data
df_cbc <-
  read.xlsx(here("dfs", "EPIC Data Exports", "2024.05.29.hems.xlsx"),
            detectDates = TRUE)
df_cbc <- clean_names(df_cbc)
df_cbc <- df_cbc %>%
  filter(cart_num == 1)
```

### Create data frame with longitudinal daily ANC values (including interpolating missing data)
```{r}
# Create data frame with longitudinal ANC values
# If last lab draw occurs after 23:00, assign ANC value to the following day
df_ancx <- df_cbc %>%
  filter(upn %in% df$upn) %>%
  select(upn, cart_date, date, time, ancx) %>%
  mutate(time = as.POSIXct(time, format = "%H:%M:%S"),
         new_date  = as.Date(ifelse(
           time >= as.POSIXct("23:00:00", format = "%H:%M:%S"),
           date + days(1),
           date
         ))) %>%
  ungroup()

df_ancx <- df_ancx %>% 
  select(-date, -time) %>% 
  rename(date = new_date)

df_ancx <- df_ancx %>% 
  mutate(time_post_inf = as.numeric(date - cart_date)) %>%
  filter(time_post_inf %in% 0:30) %>%
  distinct(upn, time_post_inf, ancx, .keep_all = TRUE) %>% # Keep unique combinations of upn, time_post_inf, and anc
  group_by(upn, time_post_inf) %>% 
  slice_min(ancx) %>% # For each combination of upn and time_post_inf, keep the lowest ANC value
  ungroup()

# Fill in missing time_post_inf and replicate UPNs by first creating df_extract
df_extract <- df %>%
  distinct(upn, cart_date, datelast)

# Create replicate_ids() to replicate UPNs according to duration of follow-up
replicate_ids <- function(upn, cart_date, datelast) {
  if (is.na(datelast) || (datelast - cart_date) >= 30) {
    return(replicate(31, upn))
  } else {
    return(replicate(datelast - cart_date + 1, upn)) # Add 1 to account for day +0
  }
}

# Create df_id with replicated UPNs
df_id <- df_extract %>%
  dplyr::rowwise() %>%
  do(data.frame(upn = replicate_ids(.$upn, .$cart_date, .$datelast))) %>% 
  group_by(upn) %>% 
  mutate(time_post_inf = row_number() - 1) %>% 
  ungroup()

# Merge df_id with df
df_ancx <- df_ancx %>%
  group_by(upn) %>%
  merge(.,
        df_id,
        by = c("upn", "time_post_inf"),
        all.y = TRUE) %>% 
  ungroup()

# Fill in cart_date and date columns
df_ancx <- df_ancx %>%
  group_by(upn) %>%
  mutate(cart_date = as.Date(ifelse(
    is.na(cart_date), max(cart_date, na.rm = TRUE), cart_date
  )),
  date = as.Date(cart_date + time_post_inf)) %>% 
  ungroup()

# Linearly interpolate missing ANC values for up to 7 consecutive NAs
df_ancx <- df_ancx %>%
  arrange(upn, time_post_inf) %>%
  group_by(upn) %>% 
  mutate(ancx = na.approx(ancx, maxgap = 7, rule = 2)) %>% 
  ungroup()

# Round ANC values to nearest integer divisible by 10 (like real ANC values)
df_ancx <- df_ancx %>% 
  mutate(ancx = round(ancx/10) * 10)

# Add UWIDs
df_ancx <- df_ancx %>%
  inner_join(., df %>% select(upn, uwid), by = "upn") %>%
  select(upn, uwid, cart_date, date, time_post_inf, ancx)

# Log10-transform ANC and select variables for clustering
df_anc <- df_ancx %>%
  mutate(anc = ifelse(ancx == 0, 0.01, ancx),
         anc = log10(anc)) %>%
  select(upn, time_post_inf, anc)

var_label(df_anc$time_post_inf) <- "Days after CAR T-cell infusion"
var_label(df_anc$anc) <- "ANC"
```

### Automatically assign eICAHT grades using {heatwaveR}
```{r}
# For eICAHT threshold of ANC ≤ 500 cells/μL
df_exceedances_below_501 <-
  # ddply splits a data frame, applies a function, and combines results into a data frame
  plyr::ddply(.data = df_ancx, .variables = c("upn", "uwid"), .fun = function(data) {
    heatwaveR::exceedance(
      data,
      x = date,
      y = ancx,
      threshold = 501,
      below = TRUE, # Whether to detect events below the threshold,
      minDuration = 1, # Minimum duration for acceptance of detected events
      joinAcrossGaps = TRUE, # Whether to join events which occur before/after gap
      maxGap = 2 # Maximum length of gap allowed for joining of events
    )$exceedance
  })

# Create data frame containing maximum duration of events for each UPN
df_anc_500 <- df_exceedances_below_501 %>%
  select(upn, uwid, exceedance_no, duration) %>%
  group_by(upn, uwid) %>%
  dplyr::summarize(duration_below_501_max = max(duration)) %>%
  mutate(duration_below_501_max = ifelse( # Replace NAs with 0 (never below threshold)
    is.na(duration_below_501_max),
    0,
    duration_below_501_max
  ))

# For eICAHT threshold of ANC ≤ 100 cells/μL
df_exceedances_below_101 <-
  plyr::ddply(.data = df_ancx, .variables = c("upn"), .fun = function(data) {
    heatwaveR::exceedance(
      data,
      x = date,
      y = ancx,
      threshold = 101,
      below = TRUE,
      minDuration = 1,
      joinAcrossGaps = TRUE,
      maxGap = 2,
      maxPadLength = FALSE
    )$exceedance
  })

df_anc_100 <- df_exceedances_below_101 %>%
  select(upn, exceedance_no, duration) %>%
  group_by(upn) %>%
  dplyr::summarize(duration_below_101_max = max(duration)) %>%
  mutate(duration_below_101_max = ifelse(
    is.na(duration_below_101_max),
    0,
    duration_below_101_max
  ))

# Create data frame with exceedances below each threshold for each UPN
df_icaht <- df_anc_500 %>% 
  left_join(., df_anc_100, by = "upn") %>% 
  ungroup()

# Create column with eICAHT grades
df_icaht <- df_icaht %>%
  mutate(
    icaht_grade = case_when(
      duration_below_501_max == 0 & duration_below_101_max == 0 ~ "Grade 0",
      duration_below_501_max %in% 1:6 & duration_below_101_max < 7 ~ "Grade 1",
      duration_below_501_max %in% 7:13 & duration_below_101_max < 7 ~ "Grade 2",
      (duration_below_501_max %in% 14:30 & duration_below_101_max < 7) |
        (duration_below_501_max < 31 & duration_below_101_max %in% 7:13) ~ "Grade 3",
      (duration_below_501_max >= 31 & duration_below_101_max < 14) | duration_below_101_max >= 14 ~ "Grade 4"
    )
  )
```

### Additionally define grade 4 eICAHT
```{r}
df_exceedances_below_501 <- df_exceedances_below_501 %>%
  filter(!is.na(exceedance_no)) %>%  # Filter out patients who never had neutropenia
  select(upn, 
         exceedance_below_501_no = exceedance_no, 
         exceedance_below_501_date_start = date_start,
         exceedance_below_501_date_end = date_end) %>% 
  mutate(exceedance_below_501_date_start = as.Date(exceedance_below_501_date_start), # Convert dates to class "Date"
         exceedance_below_501_date_end = as.Date(exceedance_below_501_date_end))

# Add date of last available ANC value
df_last_time_post_inf <- df_ancx %>%
  arrange(upn, time_post_inf) %>%
  group_by(upn) %>% 
  slice_tail(n = 1) %>% # Select last row
  ungroup() %>% 
  select(upn, 
         cart_date,
         last_lab_date = date)

df_exceedances_below_501 <- df_exceedances_below_501 %>% 
  left_join(., df_last_time_post_inf, by = "upn")

# Classify patients who had exceedances below ANC ≤ 500 cells/μL 
# starting between days 0-3 and ending on "last_lab_date" as grade 4 eICAHT
df_exceedances_below_501 <- df_exceedances_below_501 %>%
  mutate(
    icaht_grade_4 = ifelse(
      exceedance_below_501_date_start - cart_date <= 3 &
        exceedance_below_501_date_end == last_lab_date,
      "Yes",
      "No"
    )
  )

df_icaht <- df_icaht %>%
  left_join(.,
            df_exceedances_below_501 %>% select(upn, icaht_grade_4),
            by = "upn")

df_icaht <- df_icaht %>%
  mutate(
    icaht_grade = dplyr::if_else(
      icaht_grade_4 == "Yes",
      "Grade 4",
      icaht_grade,
      missing = icaht_grade
    )
  ) %>%
  distinct(upn,
           icaht_grade,
           .keep_all = TRUE)
```

### Update eICAHT grades for patients who were included in Liang, Rejeski, et al., Bone Marrow Transplantation 2024 (n = 605)
```{r}
# Data frame contains automated grades assigned by {heatwaveR} approach, MSKCC manual code, and manual grades for discrepancies
df_check <-
  read.xlsx(here("dfs",
                 "Outputs",
                 "Manual vs. Automated Early ICAHT Grades.xlsx")) %>% 
  clean_names()

# Filter to cases incorrectly graded by {heatwaveR} approach
df_check <- df_check %>% 
  filter(center == "FHCC",
         disagreement_manual_heatwave_r == 1) %>% 
  select(upn = patient_id,
         manual_icaht_grade) %>% 
  mutate(manual_icaht_grade = paste0("Grade ", manual_icaht_grade))

# Replace grades in df_icaht with correct grades
df_icaht <- df_icaht %>% 
  left_join(., df_check, by = "upn")

df_icaht <- df_icaht %>%
  mutate(icaht_grade = ifelse(!is.na(manual_icaht_grade), manual_icaht_grade, icaht_grade)) %>% 
  select(-icaht_grade_4, -manual_icaht_grade)

# Add eICAHT grades to df
df <- df %>% 
  filter(upn %in% df_icaht$upn) %>% 
  left_join(., df_icaht %>% select(upn, icaht_grade), by = "upn")

df <- df %>%
  mutate(
    icaht_grade_num = case_when(
      icaht_grade == "Grade 0" ~ 0,
      icaht_grade == "Grade 1" ~ 1,
      icaht_grade == "Grade 2" ~ 2,
      icaht_grade == "Grade 3" ~ 3,
      icaht_grade == "Grade 4" ~ 4
    ),
    icaht_grade = fct_relevel(icaht_grade, "Grade 0"),
    icaht_grade_3_4 = ifelse(icaht_grade_num %in% 3:4, 1, 0)
  )
```

### Plot ANC trajectories by ICAHT grade using {latrend}
```{r}
# Use {latrend} to create lcModel object based on reference assignments using lcModelPartition()
options(latrend.id = "upn", latrend.time = "time_post_inf")

df_anc <- df_anc %>%
  left_join(., df %>% select(upn, icaht_grade_num), by = "upn") %>% 
  mutate(icaht_grade_latrend = icaht_grade_num + 1) # latrend requires integers ≥1
  
icaht_traj_assigns <- aggregate(icaht_grade_latrend ~ upn,
                                data = df_anc,
                                FUN = data.table::first)
icaht_model <-
  lcModelPartition(
    data = df_anc,
    response = "anc",
    trajectoryAssignments = icaht_traj_assigns$icaht_grade_latrend
  )
clusterNames(icaht_model) <-
  c("Grade 0", "Grade 1", "Grade 2", "Grade 3", "Grade 4")
icaht_model

# Plot individual ANC trajectories (black lines) and cluster trajectories (colored lines)
df_icaht_traj <- trajectories(icaht_model) # Extract individual trajectories and cluster assignments
df_icaht_cluster_traj = clusterTrajectories(icaht_model) # Extract cluster trajectories
df_hline <- data.frame(threshold = factor(c("≤100 cells/μL", "≤500 cells/μL")), y = c(100, 500)) # df to plot early ICAHT thresholds

# Create new labels including cluster percentages
cluster_percentages <- prop.table(table(df_icaht_traj$Cluster))
cluster_labels <- sprintf("%s (%d%%)",
                          names(cluster_percentages),
                          round(cluster_percentages * 100))
new_labels <- as_labeller(
  c(
    "Grade 0" = cluster_labels[1],
    "Grade 1" = cluster_labels[2],
    "Grade 2" = cluster_labels[3],
    "Grade 3" = cluster_labels[4],
    "Grade 4" = cluster_labels[5]
  )
)

ggplot() +
  geom_line(
    data = df_icaht_traj,
    aes(x = time_post_inf, y = anc, group = upn),
    color = "black",
    alpha = 0.5
  ) +
  geom_line(data = df_icaht_cluster_traj,
            aes(x = time_post_inf, y = anc, color = Cluster),
            size = 2,
            show.legend = FALSE) +
  new_scale_color() +
  geom_hline(
    data = df_hline,
    aes(
      yintercept = log10(y),
      linetype = threshold,
      colour = threshold
    ),
    size = 1
  ) +
  scale_colour_manual(
    values = c("red", "blue"),
    labels = c("≤100 cells/μL", "≤500 cells/μL"),
    name = "Early ICAHT Threshold"
  ) +
  scale_linetype_manual(
    values = c("dashed", "dashed"),
    labels = c("≤100 cells/μL", "≤500 cells/μL"),
    name = "Early ICAHT Threshold"
  ) +
  facet_wrap(~ Cluster,
             labeller = new_labels) +
  scale_x_continuous(name = "Days after CAR T-cell infusion") +
  scale_y_continuous(name = "ANC (log10(cells/μL)") +
  theme(strip.text.x = element_text(size = 12),
        legend.position = c(0.85, 0.35))
```

## Import/wrangle additional data

### Clinical data
```{r}
df <- df %>%
  mutate(
    ethnih_cat = ifelse(
      ethnih == "Hispanic or Latino",
      "Hispanic or Latino",
      "Not Hispanic/Latino or Unknown"
    ),
    ethnih_cat = fct_relevel(as.factor(ethnih_cat), "Not Hispanic/Latino or Unknown"),
    raceethnih_cat = case_when(
      racenih == "White" ~ "White",
      racenih == "Black or African American" &
        ethnih == "Not Hispanic or Latino" ~ "Non-Hispanic Black or African American",
      .default = "Other"
    ),
    raceethnih_cat = fct_relevel(as.factor(raceethnih_cat), "White"),
    disease_cat =
      factor(
        disease_cat,
        levels = c(
          "Aggressive NHL",
          "Other indolent NHL",
          "ALL",
          "Mantle cell lymphoma",
          "MM/PCL"
        )
      ),
    LD_regimen_cat = factor(
      LD_regimen_cat,
      levels = c("Low-intensity Cy/Flu", "High-intensity Cy/Flu", "Other")
    ),
    product_cat = as.factor(product_cat),
    car_target = case_when(
      product_cat == "Commercial CD19-targeted CAR T-cell product with CD28 costimulatory domain" |
        product_cat == "Commercial CD19-targeted CAR T-cell product with 4-1BB costimulatory domain" |
        product_infused == "JCAR014" |
        product_infused == "JCAR021" ~ "CD19",
      product_infused == "Investigational CD20-targeted product" ~ "CD20",
      .default = "BCMA"
    ),
    car_target = factor(car_target, levels = c("BCMA", "CD19", "CD20"))
  )

var_label(df$cart_age) <- "Age"
var_label(df$gender_desc) <- "Sex"
var_label(df$racenih) <- "Race"
var_label(df$ethnih) <- "Ethnicity"
var_label(df$ethnih_cat) <- "Ethnicity"
var_label(df$raceethnih_cat) <- "Race/ethnicity"
var_label(df$disease_cat) <- "Disease"
var_label(df$prior_hct) <- "Prior HCT"
var_label(df$bm_disease_by_morph) <- "Bone marrow involvement by morphology (%)"
var_label(df$bm_disease_by_morph_log10) <- "Bone marrow involvement by morphology (log10(%))"
var_label(df$bm_disease_by_flow) <- "Bone marrow involvement by flow cytometry (%)"
var_label(df$bm_disease_by_flow_log10) <- "Bone marrow involvement by flow cytometry (log10(%))"
var_label(df$bridging_yn) <- "Bridging therapy"
var_label(df$LD_regimen_cat) <- "Lymphodepletion regimen"
var_label(df$LD_regimen_low_CyFlu_vs_other) <- "Lymphodepletion regimen (low-dose Cy/Flu vs. other)"
var_label(df$product_infused) <- "CAR T-cell product"
var_label(df$product_cat) <- "CAR T-cell product type"
var_label(df$car_target) <- "CAR target"
var_label(df$costim_domain) <- "Costimulatory domain"
var_label(df$cart_dose_total) <- "Total CAR T-cell dose (x 10^6 cells)"
var_label(df$cart_dose_total_log10) <- "Total CAR T-cell dose (log10(x 10^6 cells))"
var_label(df$anc_pre_ld) <- "Pre-LD ANC (x 10^3 cells/µL)"
var_label(df$hb_pre_ld) <- "Pre-LD Hb (g/dL)"
var_label(df$plt_pre_ld) <- "Pre-LD platelet count (x 10^3 cells/µL)"
var_label(df$anc_pre_ld_log10) <- "Pre-LD ANC (log10(x 10^3 cells/µL))"
var_label(df$anc_day_3_log10) <- "Day +3 ANC (log10(x 10^3 cells/µL))"
var_label(df$lym_pre_ld_log10) <- "Pre-LD ALC (log10(x 10^3 cells/µL))"
var_label(df$plt_pre_ld_log10) <- "Pre-LD platelet count (log10(x 10^3 /µL))"
var_label(df$plt_day_3_log10) <- "Day +3 platelet count (log10(x 10^3 /µL))"
var_label(df$ldh_pre_ld_log10) <- "Pre-LD LDH (log10(U/L))"
var_label(df$crp_pre_ld_log10) <- "Pre-LD CRP (log10(mg/L))"
var_label(df$crp_day_0_log10) <- "Day +0 CRP (log10(mg/L))"
var_label(df$crp_day_3_log10) <- "Day +3 CRP (log10(mg/L))"
var_label(df$crp_day_5_log10) <- "Day +5 CRP (log10(mg/L))"
var_label(df$crp_day_7_log10) <- "Day +7 CRP (log10(mg/L))"
var_label(df$crp_max_log10) <- "Peak CRP (log10(mg/L))"
var_label(df$ferritin_pre_ld_log10) <- "Pre-LD ferritin (log10(ng/mL))"
var_label(df$ferritin_day_0_log10) <- "Day +0 ferritin (log10(ng/mL))"
var_label(df$ferritin_day_3_log10) <- "Day +3 ferritin (log10(ng/mL))"
var_label(df$ferritin_day_5_log10) <- "Day +5 ferritin (log10(ng/mL))"
var_label(df$ferritin_day_7_log10) <- "Day +7 ferritin (log10(ng/mL))"
var_label(df$ferritin_max_log10) <- "Peak ferritin (log10(ng/mL))"
var_label(df$il6_pre_ld_log10) <- "Pre-LD IL-6 (log10(pg/mL))"
var_label(df$il6_day_0_log10) <- "Day +0 IL-6 (log10(pg/mL))"
var_label(df$il6_day_3_log10) <- "Day +3 IL-6 (log10(pg/mL))"
var_label(df$il6_day_5_log10) <- "Day +5 IL-6 (log10(pg/mL))"
var_label(df$il6_day_7_log10) <- "Day +7 IL-6 (log10(pg/mL))"
var_label(df$il6_max_log10) <- "Peak IL-6 (log10(pg/mL))"
var_label(df$fibrinogen_pre_ld_log10) <- "Pre-LD fibrinogen (log10(mg/dL))"
var_label(df$fibrinogen_day_0_log10) <- "Day +0 fibrinogen (log10(mg/dL))"
var_label(df$fibrinogen_day_3_log10) <- "Day +3 fibrinogen (log10(mg/dL))"
var_label(df$fibrinogen_day_5_log10) <- "Day +5 fibrinogen (log10(mg/dL))"
var_label(df$fibrinogen_day_7_log10) <- "Day +7 fibrinogen (log10(mg/dL))"
var_label(df$fibrinogen_min_log10) <- "Nadir fibrinogen (log10(mg/dL))"
var_label(df$d_dimer_pre_ld_log10) <- "Pre-LD D-dimer (log10(mg/L FEU))"
var_label(df$d_dimer_day_0_log10) <- "Day +0 D-dimer (log10(mg/L FEU))"
var_label(df$d_dimer_day_3_log10) <- "Day +3 D-dimer (log10(mg/L FEU))"
var_label(df$d_dimer_day_5_log10) <- "Day +5 D-dimer (log10(mg/L FEU))"
var_label(df$d_dimer_day_7_log10) <- "Day +7 D-dimer (log10(mg/L FEU))"
var_label(df$d_dimer_max_log10) <- "Peak D-dimer (log10(mg/L FEU))"
var_label(df$ptt_pre_ld_log10) <- "Pre-LD PTT (log10(seconds))"
var_label(df$ptt_day_0_log10) <- "Day +0 PTT (log10(seconds))"
var_label(df$ptt_day_3_log10) <- "Day +3 PTT (log10(seconds))"
var_label(df$ptt_day_5_log10) <- "Day +5 PTT (log10(seconds))"
var_label(df$ptt_day_7_log10) <- "Day +7 PTT (log10(seconds))"
var_label(df$ptt_max_log10) <- "Peak PTT (log10(seconds))"
var_label(df$icaht_grade) <- "eICAHT grade"
var_label(df$icaht_grade_3_4) <- "Grade 3-4 eICAHT"
var_label(df$gcsf) <- "Received G-CSF"
var_label(df$tpo_ra) <- "Received TPO-RA"
var_label(df$crs_grade) <- "CRS grade"
var_label(df$nt_grade) <- "Neurotoxicity grade"
var_label(df$iec_hs) <- "IEC-HS"
```

## Table 1: Patient, disease, and treatment characteristics
```{r}
df %>%
  select(
    cart_age,
    gender_desc,
    racenih,
    ethnih,
    prior_hct,
    disease_cat,
    bm_disease_by_morph,
    bm_disease_by_flow,
    bridging_yn,
    LD_regimen_cat,
    cart_dose_total,
    product_infused,
    product_cat,
    anc_pre_ld,
    hb_pre_ld, 
    plt_pre_ld
  ) %>%
  tbl_summary(
    missing_text = "Missing",
    type = list(all_continuous() ~ "continuous2"),
    statistic = list(
      all_continuous() ~ c("{median} ({p25}, {p75})", "{min} - {max}"),
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_categorical() ~ 0,
    sort = list(everything() ~ "frequency")
  ) %>%
  bold_labels()
```

## Bridging therapy by disease type
```{r}
df %>%
  select(disease_cat, bridging_yn) %>%
  tbl_summary(by = disease_cat) %>%
  bold_labels()
```

## Non-Cy/Flu lymphodepletion regimens
```{r}
df_LD <-
  read.xlsx(
    here(
      "dfs",
      "EPIC Data Exports",
      "2024.05.29.lymphodepletionRegimen.xlsx"
    ),
    detectDates = TRUE
  ) %>%
  clean_names()
df_LD <- df_LD %>% filter(cart_num == 1)

df_LD <- df_LD %>%
  mutate(LD_regimen = case_when(
    grepl("cyclophosphamide", dep_regimen, ignore.case = TRUE) &
      grepl("fludarabine", dep_regimen, ignore.case = TRUE) ~ "Cy/Flu",
    .default = "Other"
  ))

df_LD %>% 
  filter(
    upn %in% df$upn,
    LD_regimen == "Other") %>% 
  select(dep_regimen) %>% 
  tbl_summary()
```

## Rates of eICAHT by grade
```{r}
df %>%
  select(icaht_grade) %>%
  tbl_summary(
    statistic = list(all_categorical() ~ "{n} ({p}%)"),
    digits = all_categorical() ~ 0,
    sort = list(everything() ~ "frequency")
  ) %>%
  bold_labels()
```

## Rates of grade 3-4 eICAHT by disease type
```{r}
df %>%
  select(
    icaht_grade_3_4,
    disease_cat
  ) %>%
  tbl_summary(
    by = disease_cat) %>%
  bold_labels()
```

## Rates of CRS and neurotoxicity
```{r}
df %>%
  select(crs_grade, nt_grade) %>%
  tbl_summary(statistic = list(all_categorical() ~ "{n} ({p}%)"))
```

## Receipt of G-CSF and TPO-RAs between days 0-30 after CAR T-cell infusion
```{r}
df %>%
  select(gcsf, tpo_ra) %>%
  tbl_summary() %>%
  bold_labels()
```

## Median follow-up and overall survival
```{r}
df <- df %>%
  mutate(
    OS_status = ifelse(is.na(deathdat), 0, 1),
    OS_months = as.duration(cart_date %--% datelast) / dmonths(1)
  )

# Create data frame with OS landmarked at day +30
df_landmark_OS <- df %>% 
  filter(OS_months > 30/30.4167) %>% 
  mutate(OS_months_landmark = OS_months - 30/30.4167)

quantile(prodlim(Hist(OS_months, OS_status) ~ 1, data = df, reverse = TRUE))

surv_OS <- survfit2(Surv(OS_months, OS_status) ~ 1, data = df)
surv_OS

# 3-year estimate
summary(surv_OS, times = 36)
```

## Univariate logistic regression models of grade 3-4 eICAHT

Using log10-transformed laboratory values, except pre-LD hemoglobin due to lack of convergence with log10(pre-LD hemoglobin)

```{r, layout = "l-body-outset", fig.width = 10, fig.height = 8}
tbl_uvregression <- df %>%
  select(
    icaht_grade_3_4,
    cart_age,
    gender_desc,
    raceethnih_cat,
    prior_hct,
    disease_cat,
    bm_disease_by_morph_log10,
    bm_disease_by_flow_log10,
    bridging_yn,
    LD_regimen_cat,
    LD_regimen_low_CyFlu_vs_other,
    cart_dose_total_log10,
    car_target,
    costim_domain,
    crs_grade,
    nt_grade,
    iec_hs,
    anc_pre_ld_log10,
    anc_day_3_log10,
    hb_pre_ld,
    plt_pre_ld_log10,
    plt_day_3_log10,
    ldh_pre_ld_log10,
    crp_pre_ld_log10,
    crp_day_0_log10,
    crp_day_3_log10,
    crp_day_5_log10,
    crp_day_7_log10,
    crp_max_log10,
    ferritin_pre_ld_log10,
    ferritin_day_0_log10,
    ferritin_day_3_log10,
    ferritin_day_5_log10,
    ferritin_day_7_log10,
    ferritin_max_log10,
    il6_pre_ld_log10,
    il6_day_0_log10,
    il6_day_3_log10,
    il6_day_5_log10,
    il6_day_7_log10,
    il6_max_log10,
    fibrinogen_pre_ld_log10,
    fibrinogen_day_0_log10,
    fibrinogen_day_3_log10,
    fibrinogen_day_5_log10,
    fibrinogen_day_7_log10,
    fibrinogen_min_log10,
    d_dimer_pre_ld_log10,
    d_dimer_day_0_log10,
    d_dimer_day_3_log10,
    d_dimer_day_5_log10,
    d_dimer_day_7_log10,
    d_dimer_max_log10,
    ptt_pre_ld_log10,
    ptt_day_0_log10,
    ptt_day_3_log10,
    ptt_day_5_log10,
    ptt_day_7_log10,
    ptt_max_log10
  ) %>%
  tbl_uvregression(
    method = glm,
    y = icaht_grade_3_4,
    method.args = list(family = binomial),
    exponentiate = TRUE,
    pvalue_fun = ~ style_pvalue(.x, digits = 2)
  ) %>%
  add_nevent() %>%
  bold_p() %>%
  bold_labels()
tbl_uvregression

df_regression <- tbl_uvregression$table_body %>% 
  mutate(color = case_when(estimate < 1 & p.value < 0.05 ~ "Low",
                           estimate > 1 & p.value < 0.05 ~ "High",
                           .default = "Other"),
         color = as.factor(color))

vp <-
  ggplot(data = df_regression, aes(x = estimate, y = -log2(p.value), color = color)) +
  geom_point() +
  scale_color_manual(values = c("red", "darkgreen", "darkgray")) + 
  geom_hline(yintercept = -log2(0.05), color = "black", linetype = "dashed") +
  geom_hline(yintercept = -log2(0.01), color = "black", linetype = "dashed") +
  geom_vline(xintercept = 1, color = "black", linetype = "dashed") +
  geom_text(aes(x = 19, y = 3, label = "p = 0.05"), color = "black", stat = "unique") +
  geom_text(aes(x = 19, y = 8, label = "p = 0.01"), color = "black", stat = "unique") +
  geom_text(aes(x = 2, y = 75, label = "OR = 1"), color = "black", stat = "unique") +
  scale_x_continuous(name = "Odds of grade 3-4 eICAHT", limits = c(0, 20)) +
  coord_cartesian(clip = "off") +
  theme(legend.position = "none")

options(ggrepel.max.overlaps = Inf)
vp + geom_text_repel(data = filter(df_regression, p.value < 0.05),
                  aes(label = var_label))
```

### Summary statistics of predictors evaluated in univariate models
```{r}
df %>%
  select(
    cart_age,
    gender_desc,
    raceethnih_cat,
    prior_hct,
    disease_cat,
    bm_disease_by_morph_log10,
    bm_disease_by_flow_log10,
    bridging_yn,
    LD_regimen_cat,
    LD_regimen_low_CyFlu_vs_other,
    car_target,
    costim_domain,
    cart_dose_total_log10,
    crs_grade,
    nt_grade,
    iec_hs,
    anc_pre_ld_log10,
    anc_day_3_log10,
    hb_pre_ld,
    plt_pre_ld_log10,
    plt_day_3_log10,
    ldh_pre_ld_log10,
    crp_pre_ld_log10,
    crp_day_0_log10,
    crp_day_3_log10,
    crp_day_5_log10,
    crp_day_7_log10,
    crp_max_log10,
    ferritin_pre_ld_log10,
    ferritin_day_0_log10,
    ferritin_day_3_log10,
    ferritin_day_5_log10,
    ferritin_day_7_log10,
    ferritin_max_log10,
    il6_pre_ld_log10,
    il6_day_0_log10,
    il6_day_3_log10,
    il6_day_5_log10,
    il6_day_7_log10,
    il6_max_log10,
    fibrinogen_pre_ld_log10,
    fibrinogen_day_0_log10,
    fibrinogen_day_3_log10,
    fibrinogen_day_5_log10,
    fibrinogen_day_7_log10,
    fibrinogen_min_log10,
    d_dimer_pre_ld_log10,
    d_dimer_day_0_log10,
    d_dimer_day_3_log10,
    d_dimer_day_5_log10,
    d_dimer_day_7_log10,
    d_dimer_max_log10,
    ptt_pre_ld_log10,
    ptt_day_0_log10,
    ptt_day_3_log10,
    ptt_day_5_log10,
    ptt_day_7_log10,
    ptt_max_log10
  ) %>%
  tbl_summary(
    missing_text = "Missing",
    type = list(all_continuous() ~ "continuous2"),
    statistic = list(
      all_continuous() ~ c("{median} ({p25}, {p75})", "{min} - {max}"),
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_categorical() ~ 0,
    sort = list(everything() ~ "frequency")
  ) %>%
  bold_labels()
```

## Calculate sample size required for predicting grade 3-4 eICAHT (based on Riley et al., BMJ 2020)
```{r}
# Set Cox-Snell R squared = 0.1
# 6 predictors
pmsampsize(
  type = "b",
  nagrsquared = NA,
  csrsquared = 0.1,
  rsquared = NA,
  parameters = 6,
  shrinkage = 0.9,
  prevalence = 0.16,
  cstatistic = NA,
  seed = 123,
  rate = NA,
  timepoint = NA,
  meanfup = NA,
  intercept = NA,
  sd = NA,
  mmoe = 1.1)
```

## Development and validation of multivariable logistic regression model of grade 3-4 eICAHT: disease type, pre-LD ANC, pre-LD platelet count, pre-LD LDH, and pre-LD ferritin

### Model development and validation using {tidymodels}

Create training and test sets (70%/30%)

```{r}
# Create data frame for tidy model
df_tidy <- df %>%
  mutate(
    disease_cat = ifelse(disease_cat == "ALL", "ALL", "Other"),
    disease_cat = factor(disease_cat, levels = c("ALL", "Other")),
    bridging_yn = factor(bridging_yn, levels = c("No", "Yes"))
  ) %>%
  select(
    upn,
    icaht_grade_3_4,
    disease_cat,
    bridging_yn,
    LD_regimen_low_CyFlu_vs_other,
    anc_pre_ld_log10,
    anc_day_3_log10,
    plt_pre_ld_log10,
    plt_day_3_log10,
    ldh_pre_ld_log10,
    ferritin_pre_ld_log10,
    ferritin_day_0_log10,
    ferritin_day_3_log10,
    crp_day_3_log10,
    d_dimer_day_3_log10
  ) %>%
  mutate(icaht_grade_3_4 = factor(icaht_grade_3_4, levels = c("0", "1")))

# Split df into training set and testing set
set.seed(100)
df_split <-
  initial_split(df_tidy, prop = 0.7, strata = icaht_grade_3_4)
df_train <- training(df_split)
df_test <- testing(df_split)

df_train %>%
  count(icaht_grade_3_4) %>%
  mutate(prop = n / sum(n))

df_test %>%
  count(icaht_grade_3_4) %>%
  mutate(prop = n / sum(n))
```

Build and train logistic regression model with LASSO regularization

```{r}
# Create model recipe to pre-process data
recipe <- recipe(icaht_grade_3_4 ~ ., data = df_train) %>%
  update_role(upn, new_role = "ID") %>% # Assign upn to identifier role (as opposed to predictor or outcome)
  update_role_requirements("ID", bake = FALSE) %>% 
  step_impute_bag(
    # Impute missing values using all other predictors
    # No missing values for disease category, LD regimen, bridging therapy, pre-LD plt, or day +3 ANC/plt
    anc_pre_ld_log10,
    ldh_pre_ld_log10,
    ferritin_pre_ld_log10,
    ferritin_day_0_log10,
    ferritin_day_3_log10,
    crp_day_3_log10,
    d_dimer_day_3_log10,
    seed_val = 100
  ) %>%
  # step_zv(all_numeric(), -all_outcomes()) %>% # Remove variables containing only a single value
  step_normalize(all_numeric(), -all_outcomes()) %>% # Normalize numeric data
  step_dummy(disease_cat, bridging_yn, LD_regimen_low_CyFlu_vs_other) # Create dummy variables (nominal to numeric binary)

# Prep (apply pre-processing steps) and tidy the recipe (return data frame of pre-processing steps)
prep(recipe) %>% 
  tidy()

# Tidy step_normalize (extract mean and SD)
prep(recipe) %>% 
  tidy(number = 2)

# Build model specification
spec_model <- logistic_reg(penalty = 0.1, mixture = 1) %>%
  set_engine("glmnet")

# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + anc_pre_ld_log10 + plt_pre_ld_log10 + ldh_pre_ld_log10 + ferritin_pre_ld_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Build set of bootstrap resamples
set.seed(123)
bootstrap_resamples <-
  bootstraps(df_train, strata = icaht_grade_3_4)

# Create tuning specifications
# Set penalty = tune() instead of to a single value
tune_spec <- logistic_reg(penalty = tune(), mixture = 1) %>%
  set_engine("glmnet")

# Use penalty() to set up an appropriate grid
lambda_grid <- grid_regular(penalty(), levels = 5)

# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

# lasso_grid <- tune_grid(
#   wf %>% update_model(tune_spec, formula = model_formula),
#   resamples = bootstrap_resamples,
#   grid = lambda_grid
# )

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest AUROC
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained
# saveRDS(wf_final_trained, "eIPMPre.rds")

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_pre_ferritin_pre_ld <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_pre_ferritin_pre_ld <- cal_plot(
  df_mod_pre_ferritin_pre_ld,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPre"
)
p_cal_pre_ferritin_pre_ld

cal_plot(
  df_mod_pre_ferritin_pre_ld,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 4,
  plot_title = "eIPMPre"
)

# Plot ROC curve for test set
p_roc_pre_ferritin_pre_ld <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPre")
p_roc_pre_ferritin_pre_ld

# Plot threshold-performance plot for test set
runway::threshperf_plot(
  df_mod_pre_ferritin_pre_ld,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1"
)
```

### Calculate sensitivity/specificity of final model on test dataset using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_pre_ferritin_pre_ld,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_pre_ferritin_pre_ld <- df_mod_pre_ferritin_pre_ld %>% 
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(icaht_grade_3_4 ~ .pred_1, data = df_mod_pre_ferritin_pre_ld,
    thresholds = seq(0, 0.35, by = 0.01)) %>% 
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

### Evaluate final model on subsets of test set (ALL vs. other disease types)

ALL

```{r}
# Define test subset
df_test_all <- df_test %>% filter(disease_cat == "ALL")

# Augment test subset (i.e., add columns for predictions)
df_mod_pre_ferritin_pre_ld_all <- wf_final_trained %>%
  augment(new_data = df_test_all) 

# Calculate accuracy and AUROC
model_metrics <- metric_set(yardstick::accuracy, roc_auc)

df_mod_pre_ferritin_pre_ld_all %>%
  ungroup() %>%
  model_metrics(truth = icaht_grade_3_4,
                estimate = .pred_class,
                .pred_1,
                event_level = "second")

# Plot calibration curve using {runway}
df_mod_pre_ferritin_pre_ld_all <- df_mod_pre_ferritin_pre_ld_all %>%
  mutate(.pred_class = as.numeric(as.character(.pred_class))) %>% 
  ungroup()

cal_plot(
  df_mod_pre_ferritin_pre_ld_all,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 3,
  plot_title = "eIPMPre (ALL)"
)

# Plot ROC curve
df_mod_pre_ferritin_pre_ld_all %>%
  ungroup() %>% 
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() + 
  labs(title = "eIPMPre (ALL)")

# Calculate sensitivity/specificity using an optimal cutpoint based on the Youden index
cp <- cutpointr::cutpointr(
  data = df_mod_pre_ferritin_pre_ld_all,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

Other disease types

```{r}
# Define ther disease types test subset
df_test_other <- df_test %>% filter(disease_cat == "Other")

# Augment test subset (i.e., add columns for predictions)
df_mod_pre_ferritin_pre_ld_other <- wf_final_trained %>%
  augment(new_data = df_test_other) 

# Calculate accuracy and AUROC
df_mod_pre_ferritin_pre_ld_other %>%
  ungroup() %>%
  model_metrics(truth = icaht_grade_3_4,
                estimate = .pred_class,
                .pred_1,
                event_level = "second")

# Plot calibration curve using {runway}
df_mod_pre_ferritin_pre_ld_other <- df_mod_pre_ferritin_pre_ld_other %>%
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

cal_plot(
  df_mod_pre_ferritin_pre_ld_other,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE
)

# Plot ROC curve
df_mod_pre_ferritin_pre_ld_other %>%
  ungroup() %>% 
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot()

# Calculate sensitivity/specificity using an optimal cutpoint based on the Youden index
cp <- cutpointr::cutpointr(
  data = df_mod_pre_ferritin_pre_ld_other,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

## Development and validation of multivariable logistic regression model of grade 3-4 ICAHT: disease type, receipt of bridging therapy, pre-LD ANC, pre-LD platelet count, pre-LD LDH, and pre-LD ferritin

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + bridging_yn_Yes + anc_pre_ld_log10 +
  plt_pre_ld_log10 + ldh_pre_ld_log10 + ferritin_pre_ld_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap( ~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest accuracy
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_pre_ferritin_pre_ld_bridging <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_pre_ferritin_pre_ld_bridging <- cal_plot(
  df_mod_pre_ferritin_pre_ld_bridging,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPre (+ bridging Y/N)"
)
p_cal_pre_ferritin_pre_ld_bridging

# Plot ROC curve for test set
p_roc_pre_ferritin_pre_ld_bridging <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPre (+ bridging Y/N)")
p_roc_pre_ferritin_pre_ld_bridging
```

### Calculate sensitivity/specificity of final model on test set using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_pre_ferritin_pre_ld_bridging,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_pre_ferritin_pre_ld_bridging <- df_mod_pre_ferritin_pre_ld_bridging %>%
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(
  icaht_grade_3_4 ~ .pred_1,
  data = df_mod_pre_ferritin_pre_ld_bridging,
  thresholds = seq(0, 0.35, by = 0.01)
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

## Development and validation of multivariable logistic regression model of grade 3-4 eICAHT: disease type, lymphodepletion regimen, pre-LD ANC, pre-LD platelet count, pre-LD LDH, and pre-LD ferritin

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + LD_regimen_low_CyFlu_vs_other_Other + anc_pre_ld_log10 +
  plt_pre_ld_log10 + ldh_pre_ld_log10 + ferritin_pre_ld_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest accuracy
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_pre_ferritin_pre_ld_LD_regimen <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_pre_ferritin_pre_ld_LD_regimen <- cal_plot(
  df_mod_pre_ferritin_pre_ld_LD_regimen,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPre (+ LD regimen)"
)
p_cal_pre_ferritin_pre_ld_LD_regimen

# Plot ROC curve for test set
p_roc_pre_ferritin_pre_ld_LD_regimen <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPre (+ LD regimen)")
p_roc_pre_ferritin_pre_ld_LD_regimen
```

### Calculate sensitivity/specificity of final model on test dataset using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_pre_ferritin_pre_ld_LD_regimen,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_pre_ferritin_pre_ld_LD_regimen <- df_mod_pre_ferritin_pre_ld_LD_regimen %>%
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(
  icaht_grade_3_4 ~ .pred_1,
  data = df_mod_pre_ferritin_pre_ld_LD_regimen,
  thresholds = seq(0, 0.35, by = 0.01),
  label = list(.pred_1 = "eIPMPre")
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

## Development and validation of multivariable logistic regression model of grade 3-4 eICAHT: disease type, pre-LD ANC, pre-LD platelet count, pre-LD LDH, and day +3 ferritin

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + anc_pre_ld_log10 + plt_pre_ld_log10 + ldh_pre_ld_log10 + ferritin_day_3_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest AUROC
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained
# saveRDS(wf_final_trained, "eIPMPost.rds")

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_post_ferritin_only <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_post_ferritin_only <- cal_plot(
  df_mod_post_ferritin_only,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost"
)
p_cal_post_ferritin_only

cal_plot(
  df_mod_post_ferritin_only,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 4,
  plot_title = "eIPMPost"
)

# Plot ROC curve for test set
p_roc_post_ferritin_only <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPost")
p_roc_post_ferritin_only

# Plot threshold-performance plot for test set
runway::threshperf_plot(
  df_mod_post_ferritin_only,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1"
)
```

### Calculate sensitivity/specificity of final model on test dataset using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_post_ferritin_only,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_post_ferritin_only <- df_mod_post_ferritin_only %>% 
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(icaht_grade_3_4 ~ .pred_1, data = df_mod_post_ferritin_only,
    thresholds = seq(0, 0.35, by = 0.01)) %>% 
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

### Evaluate final model on subsets of test set (ALL vs. other disease types)

ALL

```{r}
# Augment test subset (i.e., add columns for predictions)
df_mod_post_ferritin_only_all <- wf_final_trained %>%
  augment(new_data = df_test_all) 

# Calculate accuracy and AUROC
model_metrics <- metric_set(yardstick::accuracy, roc_auc)

df_mod_post_ferritin_only_all %>%
  ungroup() %>%
  model_metrics(truth = icaht_grade_3_4,
                estimate = .pred_class,
                .pred_1,
                event_level = "second")

# Plot calibration curve using {runway}
df_mod_post_ferritin_only_all <- df_mod_post_ferritin_only_all %>%
  mutate(.pred_class = as.numeric(as.character(.pred_class))) %>% 
  ungroup()

cal_plot(
  df_mod_post_ferritin_only_all,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 3,
  plot_title = "eIPMPost (ALL)"
)

# Plot ROC curve
df_mod_post_ferritin_only_all %>%
  ungroup() %>% 
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() + 
  labs(title = "eIPMPost (ALL)")

# Calculate sensitivity/specificity using an optimal cutpoint based on the Youden index
cp <- cutpointr::cutpointr(
  data = df_mod_post_ferritin_only_all,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

Other disease types

```{r}
# Define ther disease types test subset
df_test_other <- df_test %>% filter(disease_cat == "Other")

# Augment test subset (i.e., add columns for predictions)
df_mod_post_ferritin_only_other <- wf_final_trained %>%
  augment(new_data = df_test_other) 

# Calculate accuracy and AUROC
df_mod_post_ferritin_only_other %>%
  ungroup() %>%
  model_metrics(truth = icaht_grade_3_4,
                estimate = .pred_class,
                .pred_1,
                event_level = "second")

# Plot calibration curve using {runway}
df_mod_post_ferritin_only_other <- df_mod_post_ferritin_only_other %>%
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

cal_plot(
  df_mod_post_ferritin_only_other,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost (Other disease types)"
)

# Plot ROC curve
df_mod_post_ferritin_only_other %>%
  ungroup() %>% 
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() + 
  labs(title = "eIPMPost (Other disease types)")

# Calculate sensitivity/specificity using an optimal cutpoint based on the Youden index
cp <- cutpointr::cutpointr(
  data = df_mod_post_ferritin_only_other,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

## Development and validation of multivariable logistic regression model of grade 3-4 ICAHT: disease type, receipt of bridging therapy, pre-LD ANC, pre-LD platelet count, pre-LD LDH, and day +3 ferritin

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization
```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + bridging_yn_Yes + anc_pre_ld_log10 +
  plt_pre_ld_log10 + ldh_pre_ld_log10 + ferritin_day_3_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap( ~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest accuracy
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_post_bridging <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_post_bridging <- cal_plot(
  df_mod_post_bridging,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost (+ bridging Y/N)"
)
p_cal_post_bridging

# Plot ROC curve for test set
p_roc_post_bridging <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPost (+ bridging Y/N)")
p_roc_post_bridging
```

#### Calculate sensitivity/specificity of final model on test set using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_post_bridging,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_post_bridging <- df_mod_post_bridging %>%
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(
  icaht_grade_3_4 ~ .pred_1,
  data = df_mod_post_bridging,
  thresholds = seq(0, 0.35, by = 0.01)
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

## Development and validation of multivariable logistic regression model of grade 3-4 eICAHT: disease type, pre-LD ANC, pre-LD platelet count, pre-LD LDH, day +3 ferritin, and day +3 CRP

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + anc_pre_ld_log10 + plt_pre_ld_log10 + ldh_pre_ld_log10 +
  ferritin_day_3_log10 + crp_day_3_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest AUROC
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_post_crp <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_post_crp <- cal_plot(
  df_mod_post_crp,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost (+ day +3 CRP)"
)
p_cal_post_crp

# Plot ROC curve for test set
p_roc_post_crp <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPost (+ day +3 CRP)")
p_roc_post_crp
```

### Calculate sensitivity/specificity of final model on test dataset using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_post_crp,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_post_crp <- df_mod_post_crp %>% 
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(icaht_grade_3_4 ~ .pred_1, data = df_mod_post_crp,
    thresholds = seq(0, 0.35, by = 0.01)) %>% 
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

## Development and validation of multivariable logistic regression model of grade 3-4 eICAHT: disease type, pre-LD ANC, pre-LD platelet count, pre-LD LDH, day +3 ferritin, and day +3 D-dimer

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + anc_pre_ld_log10 + plt_pre_ld_log10 + ldh_pre_ld_log10 +
  ferritin_day_3_log10 + d_dimer_day_3_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap(~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest AUROC
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_post_d_dimer <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_post_d_dimer <- cal_plot(
  df_mod_post_d_dimer,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost (+ day +3 D-dimer)"
)
p_cal_post_d_dimer

# Plot ROC curve for test set
p_roc_post_d_dimer <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPost (+ day +3 D-dimer)")
p_roc_post_d_dimer
```

### Calculate sensitivity/specificity of final model on test dataset using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_post_d_dimer,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_post_d_dimer <- df_mod_post_d_dimer %>% 
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(icaht_grade_3_4 ~ .pred_1, data = df_mod_post_d_dimer,
    thresholds = seq(0, 0.35, by = 0.01)) %>% 
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

### Development and validation of multivariable logistic regression model of grade 3-4 ICAHT: disease type, pre-LD LDH, day +3 ANC, day +3 platelet count, and day +3 ferritin

### Model development and validation using {tidymodels}

Build and train logistic regression model with LASSO regularization

```{r}
# Create model formula
model_formula <-
  icaht_grade_3_4 ~ disease_cat_Other + anc_day_3_log10 + plt_day_3_log10 + ldh_pre_ld_log10 + ferritin_day_3_log10

# Create model workflow (bundles recipe and model)
wf <- workflow() %>%
  add_model(spec_model, formula = model_formula) %>% 
  add_recipe(recipe)

# Fit model on training set
fit_train <- wf %>%
  fit(data = df_train)

# Extract estimated coefficients
fit_train %>%
  extract_fit_parsnip() %>%
  tidy()
```

Tune LASSO parameters

```{r}
# Tune grid using workflow object
doParallel::registerDoParallel()

wf_tune <- workflow() %>% 
  add_model(tune_spec, formula = model_formula) %>% 
  add_recipe(recipe)

set.seed(2023)
lasso_grid <- tune_grid(wf_tune,
                        resamples = bootstrap_resamples,
                        grid = lambda_grid)

lasso_grid %>% collect_metrics()

# Visualize performance with regularization parameter
lasso_grid %>%
  collect_metrics() %>%
  ggplot(aes(x = penalty, y = mean, color = .metric)) +
  geom_errorbar(aes(ymin = mean - std_err, ymax = mean + std_err), alpha = 0.5) +
  geom_line(linewidth = 1.5) +
  facet_wrap( ~ .metric, scales = "free", nrow = 2) +
  scale_x_log10() +
  theme(legend.position = "none")

# Select highest AUROC
highest_auroc <- lasso_grid %>%
  select_best(metric = "roc_auc")

# Finalize workflow
wf_final <-
  finalize_workflow(wf_tune,
                    highest_auroc)

# Visualize most important variables
wf_final %>%
  fit(data = df_train) %>%
  pull_workflow_fit() %>%
  vi(lambda = highest_auroc$penalty) %>%
  mutate(Importance = abs(Importance),
         Variable = fct_reorder(Variable, Importance)) %>%
  ggplot(aes(x = Importance, y = Variable, fill = Sign)) +
  geom_col() +
  scale_x_continuous(expand = c(0, 0)) +
  labs(y = NULL)
```

Fit final best model on training set and evaluate on test set

```{r}
# Fit the final best model to the training set and evaluate the test set
final_fit <- last_fit(wf_final,
                      df_split)

# Extract trained workflow from final_fit
wf_final_trained <- final_fit %>% 
  extract_workflow()
wf_final_trained

# Extract trained model from final_fit
final_fit_mod <- final_fit %>%
  extract_fit_parsnip()
final_fit_mod

# Extract estimated coefficients from final_fit
df_final_fit_coefs <- final_fit %>%
  extract_fit_parsnip() %>%
  tidy()
df_final_fit_coefs

# Compute model-specific variable importance scores for fitted model
final_fit %>% 
  extract_fit_parsnip() %>% 
  vip()

# Evaluate final model on test set
final_fit %>% collect_metrics()

# Plot calibration curve for test set
# Using {probably}
final_fit %>%
  collect_predictions() %>%
  cal_plot_breaks(
    truth = icaht_grade_3_4,
    estimate = .pred_1,
    event_level = "second",
    num_breaks = 5
  )

# Using {runway}
# Augment df_test (i.e., add columns for predictions)
df_mod_post_day_3 <- wf_final_trained %>%
  augment(new_data = df_test) %>% 
  mutate(.pred_class = as.numeric(as.character(.pred_class)))

p_cal_post_day_3 <- cal_plot(
  df_mod_post_day_3,
  outcome = "icaht_grade_3_4",
  positive = "1",
  prediction = ".pred_1",
  n_bins = 0,
  show_loess = TRUE,
  plot_title = "eIPMPost (day +3 ANC/plt)"
)
p_cal_post_day_3

# Plot ROC curve for test set
p_roc_post_day_3 <- final_fit %>%
  collect_predictions() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second") %>%
  autoplot() +
  labs(title = "eIPMPost (day +3 ANC/plt)")
p_roc_post_day_3
```

#### Calculate sensitivity/specificity of final model on test set using an optimal cutpoint based on the Youden index
```{r}
cp <- cutpointr::cutpointr(
  data = df_mod_post_day_3,
  x = .pred_1,
  class = icaht_grade_3_4,
  direction = ">=",
  pos_class = 1,
  method = maximize_metric,
  metric = youden,
  na.rm = TRUE
)
summary(cp)
```

### Decision curve analysis of final model fitted on test set
```{r}
df_mod_post_day_3 <- df_mod_post_day_3 %>% 
  mutate(icaht_grade_3_4 = fct_relevel(icaht_grade_3_4, c("0", "1")))

dcurves::dca(icaht_grade_3_4 ~ .pred_1,
             data = df_mod_post_day_3,
             thresholds = seq(0, 0.35, by = 0.01)) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

## Decision curve analyses of grade 3-4 eICAHT prediction models (eIPM)

### eIPMPre vs. eIPMPost
```{r}
df_mod_all <- df_mod_pre_ferritin_pre_ld %>%
  rename(predictions_pre_ferritin_pre_ld = .pred_1) %>%
  left_join(
    .,
    df_mod_pre_ferritin_pre_ld_bridging %>% select(upn, predictions_pre_ferritin_pre_ld_bridging = .pred_1),
    by = "upn"
  ) %>%
  left_join(
    .,
    df_mod_pre_ferritin_pre_ld_LD_regimen %>% select(upn, predictions_pre_ferritin_pre_ld_LD_regimen = .pred_1),
    by = "upn"
  ) %>%
  left_join(
    .,
    df_mod_post_ferritin_only %>% select(upn, predictions_post_ferritin_only = .pred_1),
    by = "upn"
  ) %>%
  left_join(.,
            df_mod_post_bridging %>% select(upn, predictions_post_bridging = .pred_1),
            by = "upn") %>%
  left_join(.,
            df_mod_post_crp %>% select(upn, predictions_post_crp = .pred_1),
            by = "upn") %>%
  left_join(.,
            df_mod_post_d_dimer %>% select(upn, predictions_post_d_dimer = .pred_1),
            by = "upn") %>%
  left_join(.,
            df_mod_post_day_3 %>% select(upn, predictions_post_day_3 = .pred_1),
            by = "upn") %>%
  select(
    upn,
    icaht_grade_3_4,
    predictions_pre_ferritin_pre_ld,
    predictions_pre_ferritin_pre_ld_bridging,
    predictions_pre_ferritin_pre_ld_LD_regimen,
    predictions_post_ferritin_only,
    predictions_post_bridging,
    predictions_post_crp,
    predictions_post_d_dimer,
    predictions_post_day_3
  )

dcurves::dca(
  icaht_grade_3_4 ~ predictions_pre_ferritin_pre_ld + predictions_post_ferritin_only,
  data = df_mod_all,
  thresholds = seq(0, 0.35, by = 0.01),
  label = list(
    predictions_pre_ferritin_pre_ld = "eIPMPre",
    predictions_post_ferritin_only = "eIPMPost"
  )
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")
```

### All eIPMPres and eIPMPosts
```{r, layout = "l-body-outset", fig.width = 8, fig.height = 10}
p_dca_pre_all <- dcurves::dca(
  icaht_grade_3_4 ~ predictions_pre_ferritin_pre_ld + predictions_pre_ferritin_pre_ld_bridging +
    predictions_pre_ferritin_pre_ld_LD_regimen,
  data = df_mod_all,
  thresholds = seq(0, 0.35, by = 0.01),
  label = list(
    predictions_pre_ferritin_pre_ld = "eIPMPre",
    predictions_pre_ferritin_pre_ld_bridging = "eIPMPre (+ bridging Y/N)",
    predictions_pre_ferritin_pre_ld_LD_regimen = "eIPMPre (+ LD regimen)"
  )
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")

p_dca_post_all <- dcurves::dca(
  icaht_grade_3_4 ~ predictions_post_ferritin_only + predictions_post_bridging + predictions_post_crp +
    predictions_post_d_dimer + predictions_post_day_3,
  data = df_mod_all,
  thresholds = seq(0, 0.35, by = 0.01),
  label = list(
    predictions_post_ferritin_only = "eIPMPost",
    predictions_post_bridging = "eIPMPost (+ bridging Y/N)",
    predictions_post_crp ="eIPMPost (+ day +3 CRP)",
    predictions_post_d_dimer ="eIPMPost (+ day +3 D-dimer)",
    predictions_post_day_3 = "eIPMPost (day +3 ANC/plt)"
  )
) %>%
  plot(smooth = TRUE) +
  labs(x = "Threshold Probability (Physician/Patient Preference)")

p <- p_dca_pre_all + p_dca_post_all
p + plot_layout(ncol = 1) + plot_annotation(tag_levels = "A")
```

## ROC curves of all eIPMPres and eIPMPosts
```{r, layout = "l-body-outset", fig.width = 8, fig.height = 10}
# Create ROC data frames for each model
df_roc_pre_ferritin_pre_ld <- df_mod_pre_ferritin_pre_ld %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_pre_ferritin_pre_ld_bridging <- df_mod_pre_ferritin_pre_ld_bridging %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_pre_ferritin_pre_ld_LD_regimen <- df_mod_pre_ferritin_pre_ld_LD_regimen %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_post_ferritin_only <- df_mod_post_ferritin_only %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_post_bridging <- df_mod_post_bridging %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_post_crp <- df_mod_post_crp %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_post_d_dimer <- df_mod_post_d_dimer %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

df_roc_post_day_3 <- df_mod_post_day_3 %>%
  ungroup() %>%
  roc_curve(truth = icaht_grade_3_4, .pred_1, event_level = "second")

# eIPMPres
p_roc_pre_all <- df_roc_pre_ferritin_pre_ld %>%
  mutate(model = "eIPMPre") %>%
  bind_rows(
    df_roc_pre_ferritin_pre_ld_bridging %>% mutate(model = "eIPMPre (+ bridging Y/N)"),
    df_roc_pre_ferritin_pre_ld_LD_regimen %>% mutate(model = "eIPMPre (+ LD regimen)")
  ) %>%
  ggplot(aes(
    x = 1 - specificity,
    y = sensitivity,
    color = model
  )) +
  geom_path(size = 1) +
  geom_abline(lty = 3) +
  labs(color = "Model")

# eIPMPosts
p_roc_post_all <- df_roc_post_ferritin_only %>%
  mutate(model = "eIPMPost") %>%
  bind_rows(
    df_roc_post_bridging %>% mutate(model = "eIPMPost (+ bridging Y/N)"),
    df_roc_post_crp %>% mutate(model = "eIPMPost (+ day +3 CRP)"),
    df_roc_post_d_dimer %>% mutate(model = "eIPMPost (+ day +3 D-dimer)"),
    df_roc_post_day_3 %>% mutate(model = "eIPMPost (day +3 ANC/plt)")
  ) %>%
  ggplot(aes(
    x = 1 - specificity,
    y = sensitivity,
    color = model
  )) +
  geom_path(size = 1) +
  geom_abline(lty = 3) +
  labs(color = "Model")

p <- p_roc_pre_all + p_roc_post_all
p + plot_layout(ncol = 1) + plot_annotation(tag_levels = "A")
```

## Characteristics of training and test sets
```{r}
tbl_train <- df %>% 
  filter(upn %in% df_train$upn) %>% 
  select(
    cart_age,
    gender_desc,
    racenih,
    ethnih,
    prior_hct,
    disease_cat,
    bm_disease_by_morph,
    bm_disease_by_flow,
    bridging_yn,
    LD_regimen_cat,
    product_infused,
    product_cat,
    costim_domain,
    anc_pre_ld,
    hb_pre_ld, 
    plt_pre_ld
  ) %>%
  tbl_summary(
    missing_text = "Missing",
    type = list(all_continuous() ~ "continuous2"),
    statistic = list(
      all_continuous() ~ c("{median} ({p25}, {p75})", "{min} - {max}"),
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_categorical() ~ 0,
    sort = list(everything() ~ "frequency")
  ) %>%
  bold_labels()

tbl_test <- df %>% 
  filter(upn %in% df_test$upn) %>% 
  select(
    cart_age,
    gender_desc,
    racenih,
    ethnih,
    prior_hct,
    disease_cat,
    bm_disease_by_morph,
    bm_disease_by_flow,
    bridging_yn,
    LD_regimen_cat,
    product_infused,
    product_cat,
    costim_domain,
    anc_pre_ld,
    hb_pre_ld, 
    plt_pre_ld
  ) %>%
  tbl_summary(
    missing_text = "Missing",
    type = list(all_continuous() ~ "continuous2"),
    statistic = list(
      all_continuous() ~ c("{median} ({p25}, {p75})", "{min} - {max}"),
      all_categorical() ~ "{n} ({p}%)"
    ),
    digits = all_categorical() ~ 0,
    sort = list(everything() ~ "frequency")
  ) %>%
  bold_labels()

tbl_merge(
  tbls = list(tbl_train, tbl_test),
  tab_spanner = c("**Training cohort**", "**Test cohort**")
)
```

## 5th and 95th percentiles of numeric variables in eIPMs
```{r}
df %>% 
  filter(upn %in% df_train$upn) %>% 
  plyr::summarize(
    anc_pre_ld_5p = quantile(anc_pre_ld, 0.05, na.rm = TRUE),
    plt_pre_ld_5p = quantile(plt_pre_ld, 0.05, na.rm = TRUE),
    ldh_pre_ld_5p = quantile(ldh_pre_ld, 0.05, na.rm = TRUE),
    ferritin_pre_ld_5p = quantile(ferritin_pre_ld, 0.05, na.rm = TRUE),
    ferritin_day_3_5p = quantile(ferritin_day_3, 0.05, na.rm = TRUE)
  )

df %>% 
  filter(upn %in% df_train$upn) %>% 
  plyr::summarize(
    anc_pre_ld_95p = quantile(anc_pre_ld, 0.95, na.rm = TRUE),
    plt_pre_ld_95p = quantile(plt_pre_ld, 0.95, na.rm = TRUE),
    ldh_pre_ld_95p = quantile(ldh_pre_ld, 0.95, na.rm = TRUE),
    ferritin_pre_ld_95p = quantile(ferritin_pre_ld, 0.95, na.rm = TRUE),
    ferritin_day_3_95p = quantile(ferritin_day_3, 0.95, na.rm = TRUE)
  )
```

## Duration of neutropenia (ANC ≤ 500 cells/μL) by probability of severe eICAHT predicted by eIPMs
```{r, layout = "l-body-outset", fig.width = 6, fig.height = 8}
# eIPMPre
df_mod_pre_ferritin_pre_ld <- df_mod_pre_ferritin_pre_ld %>%
  left_join(., df_icaht %>% select(upn, duration_below_501_max), by = "upn") %>%
  mutate(.pred_1_as_percentage = .pred_1 * 100)

# Calculate correlation coefficient and p-value
cor_test <- cor.test(
  df_mod_pre_ferritin_pre_ld$.pred_1_as_percentage,
  df_mod_pre_ferritin_pre_ld$duration_below_501_max
)
cor_coef <- cor_test$estimate
cor_coef
p_value <- cor_test$p.value
p_value

p1 <- df_mod_pre_ferritin_pre_ld %>%
  ggplot(aes(x = .pred_1_as_percentage, y = duration_below_501_max)) +
  geom_point() +
  geom_smooth(method = "lm",
              se = FALSE,
              color = "blue") +  # Add linear regression line
  labs(x = "Probability of Severe eICAHT (%) Predicted by eIPMPre",
       y = "Duration of Neutropenia (Days)") +
  annotate(
    "text",
    x = 90,
    y = 5,
    label = paste("r =", round(cor_coef, 2), "\np < 0.001"),
    hjust = 0,
    vjust = 1,
    size = 4,
    color = "red"
  )

# eIPMPost
df_mod_post_ferritin_only <- df_mod_post_ferritin_only %>%
  left_join(., df_icaht %>% select(upn, duration_below_501_max), by = "upn") %>%
  mutate(.pred_1_as_percentage = .pred_1 * 100)

# Calculate correlation coefficient and p-value
cor_test <- cor.test(
  df_mod_post_ferritin_only$.pred_1_as_percentage,
  df_mod_post_ferritin_only$duration_below_501_max
)
cor_coef <- cor_test$estimate
cor_coef
p_value <- cor_test$p.value
p_value

p2 <- df_mod_post_ferritin_only %>%
  ggplot(aes(x = .pred_1_as_percentage, y = duration_below_501_max)) +
  geom_point() +
  geom_smooth(method = "lm",
              se = FALSE,
              color = "blue") +  # Add linear regression line
  labs(x = "Probability of Severe eICAHT (%) Predicted by eIPMPost", 
       y = "Duration of Neutropenia (Days)") +
  annotate(
    "text",
    x = 90,
    y = 5,
    label = paste("r =", round(cor_coef, 2), "\np < 0.001"),
    hjust = 0,
    vjust = 1,
    size = 4,
    color = "red"
  )

p <- p1 + p2
p + plot_layout(ncol = 1) + plot_annotation(tag_levels = "A")
```

## Univariate Cox regression models of overall survival by probability of severe eICAHT predicted by eIPMs
```{r}
# eIPMPre
df_mod_pre_ferritin_pre_ld <- df_mod_pre_ferritin_pre_ld %>%
  left_join(., df %>% select(upn, OS_status, OS_months), by = "upn")
  
tbl_pre <- coxph(Surv(OS_months, OS_status) ~ .pred_1_as_percentage,
                 data = df_mod_pre_ferritin_pre_ld) %>%
  tbl_regression(exponentiate = TRUE) %>% 
  bold_p()

# eIPMPost
df_mod_post_ferritin_only <- df_mod_post_ferritin_only %>%
  left_join(., df %>% select(upn, OS_status, OS_months), by = "upn")

tbl_post <- coxph(Surv(OS_months, OS_status) ~ .pred_1_as_percentage, 
                  data = df_mod_post_ferritin_only) %>%
  tbl_regression(exponentiate = TRUE) %>% 
  bold_p()

tbl_stack(
  list(tbl_pre, tbl_post),
  group_header =
    c(
      "eIPMPre",
      "eIPMPost"
    )
) %>%
  modify_header(label = "**Probability of severe eICAHT predicted by by eIPM**")
```

## Evaluation of CAR-HEMATOTOX score on test set

### Compute CAR-HEMATOTOX scores
```{r}
# Impute missing data
df_car_hematotox <- df %>%
  filter(upn %in% df_test$upn) %>% 
  select(upn,
         icaht_grade_3_4,
         anc_pre_ld,
         hb_pre_ld,
         plt_pre_ld,
         crp_pre_ld,
         ferritin_pre_ld) 

recipe <- recipe(icaht_grade_3_4 ~ ., data = df_car_hematotox) %>%
  update_role(upn, new_role = "ID") %>%
  update_role_requirements("ID", bake = FALSE) %>%
  step_impute_bag(anc_pre_ld,
                  hb_pre_ld,
                  plt_pre_ld,
                  crp_pre_ld,
                  ferritin_pre_ld,
                  seed_val = 100) 

# Extract processed dataframe
df_car_hematotox <- recipe %>% 
  prep() %>% 
  bake(new_data = NULL)

# Calculate CAR-HEMATOTOX score (continuous)
df_car_hematotox <- df_car_hematotox %>%
  mutate(
    plt_hematotox_score = case_when(
      plt_pre_ld > 175 ~ 0,
      plt_pre_ld %in% c(75:175) ~ 1,
      plt_pre_ld < 75 ~ 2,
      is.na(plt_pre_ld) ~ NA_real_
    ),
    anc_hematotox_score = case_when(
      anc_pre_ld > 1.2 ~ 0,
      anc_pre_ld < 1.2 ~ 1,
      is.na(anc_pre_ld) ~ NA_real_
    ),
    hb_hematotox_score = case_when(hb_pre_ld > 9 ~ 0,
                                   hb_pre_ld < 9 ~ 1,
                                   is.na(hb_pre_ld) ~ NA_real_),
    crp_hematotox_score = case_when(crp_pre_ld < 3 ~ 0,
                                    crp_pre_ld > 3 ~ 1,
                                    is.na(crp_pre_ld) ~ NA_real_),
    ferritin_hematotox_score = case_when(
      ferritin_pre_ld < 650 ~ 0,
      ferritin_pre_ld %in% c(650:2000) ~ 1,
      ferritin_pre_ld > 2000 ~ 2,
      is.na(ferritin_pre_ld) ~ NA_real_
    )
  )

# Calculate CAR-HEMATOTOX score (categorical)
df_car_hematotox <- df_car_hematotox %>%
  mutate(
    car_hematotox_score = rowSums(across(
      plt_hematotox_score:ferritin_hematotox_score
    )),
    car_hematotox_categorical = case_when(car_hematotox_score < 2 ~ "Low",
                                        car_hematotox_score >= 2 ~ "High"),
    car_hematotox_categorical = as.factor(car_hematotox_categorical),
    car_hematotox_categorical = fct_relevel(car_hematotox_categorical, c("Low", "High"))
  )

var_label(df_car_hematotox$car_hematotox_score) <- "CAR-HEMATOTOX score (continuous)"
var_label(df_car_hematotox$car_hematotox_categorical) <- "CAR-HEMATOTOX score (categorical)"
```

### Sensitivity, specificity, and AUROC for CAR-HEMATOTOX score in predicting grade 3-4 ICAHT
```{r}
# Sensitivity and specificity based on confusion matrix
df_matrix <- df_car_hematotox %>% 
  select(upn, icaht_grade_3_4, car_hematotox_categorical) %>% 
  mutate(car_hematotox_high = ifelse(car_hematotox_categorical == "High", 1, 0)) %>% 
  drop_na()

observed_value <- factor(df_matrix$icaht_grade_3_4, levels = c("1", "0"))
predicted_value <- factor(df_matrix$car_hematotox_high, levels = c("1", "0"))

matrix <-
  confusionMatrix(data = predicted_value,
                  reference = observed_value,
                  positive = "1")
matrix

# ROC
Epi::ROC(df_matrix$car_hematotox_high, df_matrix$icaht_grade_3_4)
```

## Computational environment
```{r}
devtools::session_info() 
```